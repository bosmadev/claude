# Future: Deferred Features, Migration Paths & SDK Enhancements

**Created:** 2026-01-29
**Last Updated:** 2026-01-31T00:00:00Z
**SDK Version:** `claude-agent-sdk` v0.1.25
**Package:** `pip install claude-agent-sdk` (Python) | `npm install @anthropic-ai/claude-agent-sdk` (TypeScript)
**Docs:** https://platform.claude.com/docs/en/agent-sdk/overview
**Source Plan:** `plans/snug-hugging-squirrel.md` (Hybrid Ralph Architecture)

This file documents:
- **Part I:** Features explicitly deferred during the Hybrid Ralph Architecture design process, with migration paths
- **Part II:** Claude Agent SDK enhancement roadmap for Ralph/GSwarm integration

---

## Part I: Deferred Features & Migration Paths

---

## 1. tmux Panes Option

**Deferred from:** Decision 1 (Agent Spawning)
**Status:** Deferred — viable on WSL2 (tmux is available)

### Concept

Instead of (or in addition to) Task tool spawning, Ralph agents could be spawned in individual tmux panes. This gives operators a visual terminal multiplexer view of all active agents, with real-time scrolling output per agent.

```
┌─────────────────────────────────────────────────────────┐
│ tmux session: ralph-{session-id}                        │
├──────────────┬──────────────┬──────────────┬────────────┤
│ Agent 0      │ Agent 1      │ Agent 2      │ Agent 3    │
│ (leader)     │ (security)   │ (arch)       │ (perf)     │
│ > reviewing  │ > claiming   │ > editing    │ > idle     │
│   task-4...  │   task-7...  │   file.ts..  │            │
├──────────────┴──────────────┴──────────────┴────────────┤
│ Main Session (orchestrator)                              │
│ > Agents: 4/4 active | Queue: 3 pending | Phase: impl   │
└─────────────────────────────────────────────────────────┘
```

### Implementation Sketch

```bash
# Create tmux session with N panes
tmux new-session -d -s "ralph-${SESSION_ID}" -x 200 -y 50

for i in $(seq 0 $((N_AGENTS - 1))); do
  if [ $i -gt 0 ]; then
    tmux split-window -t "ralph-${SESSION_ID}"
  fi
  tmux send-keys -t "ralph-${SESSION_ID}" \
    "claude --print --verbose '${AGENT_PROMPT}'" Enter
done

tmux select-layout -t "ralph-${SESSION_ID}" tiled
```

### CLI Integration

Add `--backend tmux` to the existing `--backend task|subprocess|auto` flag:

```
ralph.py setup --agents 4 --backend tmux    # All agents in tmux panes
ralph.py setup --agents 12 --backend auto    # Task(10) + tmux overflow
```

### Trade-offs

| Aspect | tmux Panes | Task Tool |
| --- | --- | --- |
| Visual monitoring | Real-time scrolling output per agent | Status in `/tasks` dropdown |
| Context window | 200k (own process) | 200k (own context) |
| MCP access | None (`--print` mode) | Full (Serena, Context7) |
| UI integration | Separate terminal | Native Claude Code UI |
| Max concurrent | Unlimited | ~10 (batching required) |
| Crash visibility | Pane exits visibly | TaskOutput error code |

### Why Deferred

- Task tool provides native Claude Code UI integration, which is the primary goal
- tmux panes lack MCP access (Serena, Context7), limiting agent capability
- Task tool agents get native crash recovery; tmux agents need custom PID tracking
- tmux adds a dependency on terminal state that complicates headless/CI operation

### When to Revisit

- If Task tool concurrency limits (<10) become a bottleneck for large teams
- If visual debugging of agent output becomes a frequent need
- If `CLAUDE_CODE_TMUX_*` env vars ship in a future Claude Code release

---

## 2. TeammateTool Migration

**Deferred from:** Decision 2 (TeammateTool)
**Status:** TeammateTool is feature-flagged in Claude Code v2.1.23 -- NOT available for use

### What We Built (File-Based Team Infra)

Since TeammateTool is not yet GA, we built equivalent functionality using the filesystem:

**Team Registry:**
```
.claude/ralph/team-{session}/
├── config.json              # Team metadata: session ID, agent count, phase, created_at
├── inbox/
│   ├── agent-0.json         # Per-agent message inbox (append-only with fcntl.flock)
│   ├── agent-1.json
│   └── ...
├── heartbeat-agent-0.json   # Last-seen timestamps (5-min interval)
├── heartbeat-agent-1.json
└── relay.json               # Shared relay for broadcast messages
```

**Message Types (10 total for Hybrid Gamma):**

| Message | Direction | Purpose |
| --- | --- | --- |
| `task_completed` | Agent -> Relay | Agent finished a task |
| `idle_notification` | Agent -> Relay | Agent has no work |
| `shutdown_request` | Leader -> All | Graceful shutdown initiated |
| `shutdown_approved` | Agent -> Leader | Agent acknowledges shutdown |
| `phase_change` | Leader -> All | Phase transition (impl -> review) |
| `plan_approval_request` | Leader -> Main | Request user approval |
| `delegation` | Agent -> Agent | Delegate subtask |
| `teleport` | Agent -> Agent | Transfer session context |
| `remote_sync` | Agent -> Remote | Push state to remote |
| `permission_request` | Agent -> Leader | Request elevated access |

**SpawnBackend Interface:**
```python
class SpawnBackend(ABC):
    @abstractmethod
    async def spawn_agent(self, agent_id: str, prompt: str, config: dict) -> AgentHandle: ...

    @abstractmethod
    async def get_status(self, handle: AgentHandle) -> AgentStatus: ...

    @abstractmethod
    async def send_message(self, handle: AgentHandle, message: dict) -> None: ...

    @abstractmethod
    async def terminate(self, handle: AgentHandle) -> None: ...

class TaskToolBackend(SpawnBackend):
    """Spawns agents via Claude Code Task tool."""
    ...

class SubprocessBackend(SpawnBackend):
    """Spawns agents via asyncio.create_subprocess_exec."""
    ...
```

### What Changes When TeammateTool Ships

When TeammateTool becomes GA (estimated: Claude Code v2.2+), the following swaps occur:

**1. SpawnBackend Implementation Swap**

```python
# Before (file-based)
class TaskToolBackend(SpawnBackend):
    async def spawn_agent(self, agent_id, prompt, config):
        # Uses Task(prompt, run_in_background=True)
        ...

# After (TeammateTool native)
class TeammateToolBackend(SpawnBackend):
    async def spawn_agent(self, agent_id, prompt, config):
        # Uses TeammateTool.create_teammate(name, role, prompt)
        ...
```

**2. Inbox Redirect to Native Mailbox**

```python
# Before: file-based inbox
def send_message(agent_id, message):
    inbox_path = f".claude/ralph/team-{session}/inbox/{agent_id}.json"
    with fcntl.flock(open(inbox_path, 'a')):
        json.dump(message, f)

# After: native TeammateTool mailbox
def send_message(agent_id, message):
    TeammateTool.send_message(agent_id, message)
```

**3. Team Discovery**

```python
# Before: file scan
def discover_team():
    return glob(".claude/ralph/team-*/config.json")

# After: native API
def discover_team():
    return TeammateTool.list_teammates()
```

**4. Heartbeat and Status**

```python
# Before: file timestamp polling
def check_alive(agent_id):
    heartbeat = read_json(f"heartbeat-{agent_id}.json")
    return (now() - heartbeat["last_seen"]).seconds < 300

# After: native status
def check_alive(agent_id):
    return TeammateTool.get_status(agent_id).is_alive
```

### Migration Checklist

When TeammateTool becomes available:

- [ ] **Verify GA status** -- Confirm TeammateTool is no longer feature-flagged
- [ ] **API surface audit** -- Compare our 10 message types against TeammateTool's native message API
- [ ] **Create `TeammateToolBackend`** -- New `SpawnBackend` implementation using native API
- [ ] **Swap default backend** -- Change `--backend auto` to prefer TeammateTool over Task tool
- [ ] **Redirect inbox** -- Replace file-based `inbox/{agent-id}.json` with `TeammateTool.send_message()`
- [ ] **Redirect team registry** -- Replace `team-{session}/config.json` with `TeammateTool.list_teammates()`
- [ ] **Redirect heartbeat** -- Replace file-based heartbeat polling with `TeammateTool.get_status()`
- [ ] **Map env vars** -- Ensure `CLAUDE_CODE_TEAM_NAME`, `CLAUDE_CODE_AGENT_ID`, `CLAUDE_CODE_AGENT_NAME` align with native expectations
- [ ] **Test leader election** -- Verify `leader.lock` mechanism works with native teammate lifecycle
- [ ] **Test negotiated shutdown** -- Verify `shutdown_request` -> ACK -> timeout flow through native mailbox
- [ ] **Remove file-based fallback** -- Once stable, deprecate file-based inbox (keep as `--backend file` for offline use)
- [ ] **Update documentation** -- Remove file-based team infra docs, add TeammateTool configuration

### Compatibility Notes

- Our file formats (`.claude/teams/` schema) were designed to match the kieranklaassen gist expectations
- Env vars `CLAUDE_CODE_TEAM_NAME`, `CLAUDE_CODE_AGENT_ID`, `CLAUDE_CODE_AGENT_NAME` use the `CLAUDE_CODE_` prefix specifically for forward compatibility
- The `SpawnBackend` abstraction means the swap is a single class replacement, not a rewrite

---

## 3. Alpha/Beta Fallbacks (Inter-Agent Communication)

**Deferred from:** Decision 6 (Inter-Agent Communication)
**Status:** Hybrid Gamma approved. Alpha and Beta serve as fallback options if Gamma implementation fails or proves too complex.

### Hybrid Alpha: Minimal Coordination

**Effort:** 1-2 weeks | ~100 lines new code | Low risk

Use this fallback if Hybrid Gamma's leader agent, memory persistence, or 10-message-type system proves unworkable within the timeline.

| Sub-Decision | Alpha Choice |
| --- | --- |
| Leader (6A) | No leader -- peer swarm, all agents equal |
| Inbox (6B) | File-based JSON per agent (leverages `fcntl.flock`) |
| Messages (6C) | 3 types: `task_completed`, `idle_notification`, `shutdown_request` |
| Approval (6D) | Skip -- agents work autonomously (post-hoc review only) |
| Shutdown (6E) | Signal-based with 10s grace (existing 900s timeout) |

**What Alpha drops from Gamma:**
- No dedicated leader agent (saves 1 Task slot)
- No `delegation`, `teleport`, `remote_sync`, `permission_request` messages
- No relay file or ACK tracking
- No plan approval gate between iterations
- No memory persistence across iterations
- Review agents read `.claude/review-agents.md` only (no inbox participation)

**What Alpha keeps:**
- Work-stealing queue with `fcntl.flock` atomicity
- File-based per-agent inbox (3 message types)
- Push gate enforcement
- Agent configs from `/usr/share/claude/agents/`
- Phase transitions (implementation -> review -> complete)

**When to fall back to Alpha:**
- Gamma leader election proves unreliable with >5 agents
- 10-message-type system creates too much file contention under 15 agents
- Memory persistence causes stale state bugs between iterations
- Timeline pressure requires a working system within 2 weeks

### Hybrid Beta: Gist-Compatible Relay

**Effort:** 3-4 weeks | ~250 lines new code | Moderate risk

Use this fallback if Alpha is too minimal but Gamma is too complex. Beta provides 85% gist compatibility without the full leader/memory system.

| Sub-Decision | Beta Choice |
| --- | --- |
| Leader (6A) | Main session as relay coordinator (not a separate agent) |
| Inbox (6B) | Shared relay `.claude/ralph/relay.json` + per-agent ACK tracking |
| Messages (6C) | 6 types: Alpha's 3 + `shutdown_approved`, `phase_change`, `plan_approval_request` |
| Approval (6D) | Optional first-iteration gate (user reviews before iteration 2) |
| Shutdown (6E) | Negotiated: `shutdown_request` -> agents ACK -> 30s timeout -> SIGTERM |

**What Beta adds over Alpha:**
- Main session acts as relay coordinator (no dedicated agent slot consumed)
- Shared relay file with ACK tracking for reliable message delivery
- 3 additional message types for phase coordination
- Optional approval gate between iterations
- Negotiated shutdown (prevents lost work)
- TTL on messages (prevents stale state)

**What Beta drops from Gamma:**
- No dedicated leader agent (main session coordinates instead)
- No `delegation`, `teleport`, `remote_sync`, `permission_request` messages
- No per-agent memory persistence
- No TeammateBridge relay emulation
- 85% gist compatibility (vs 100% for Gamma)

**Known limitation:** Relay file contention under 15 agents. Mitigation: per-phase relay files (`relay-impl.json`, `relay-review.json`).

**When to fall back to Beta:**
- Gamma's dedicated leader agent consumes too much of the ~10 Task slot budget
- Full 10-message-type system is overengineered for current use cases
- Need gist compatibility but not full TeammateTool emulation
- Timeline allows 3-4 weeks but not 6-8

### Comparison (Quick Reference)

| Aspect | Alpha | Beta | Gamma |
| --- | --- | --- | --- |
| Timeline | 1-2 weeks | 3-4 weeks | 6-8 weeks |
| New code | ~100 lines | ~250 lines | ~800 lines |
| Gist compat | 30% | 85% | 100% |
| Test coverage needed | 60% | 75% | 90%+ |
| Best for | MVP/PoC | Production (1-5 agents) | Enterprise (10+ agents) |
| Leader | None (peer swarm) | Main session as relay | Dedicated agent-0 |
| Message types | 3 | 6 | 10 |
| Memory persistence | None | None | Full (shared.mem) |

### Escalation Path

```
Gamma fails → Try Beta (drop leader agent, reduce to 6 messages)
Beta fails  → Try Alpha (drop relay, reduce to 3 messages)
Alpha fails → Keep current subprocess model (no inter-agent comms)
```

---

## 4. Environment Variable Breakage Risks

**Deferred from:** Decision 4 (Environment Variables)
**Status:** Risks documented. Variables using `CLAUDE_CODE_*` prefix may conflict with future Claude Code releases.

### Approved Variable Mapping (Current)

| Variable | Prefix | Purpose |
| --- | --- | --- |
| `CLAUDE_CODE_TEAM_NAME` | CLAUDE_CODE | Team identifier (matches both gists) |
| `CLAUDE_CODE_AGENT_ID` | CLAUDE_CODE | Unique agent identifier |
| `CLAUDE_CODE_AGENT_NAME` | CLAUDE_CODE | Human-readable agent display name |
| `RALPH_AGENT_TYPE` | RALPH | Agent role type (impl/review/leader) |
| `RALPH_PARENT_SESSION_ID` | RALPH | Parent orchestrator session |
| `RALPH_SUBAGENT` | RALPH | Boolean flag: is this a subagent? |
| `RALPH_INITIAL_HEAD` | RALPH | Git HEAD at spawn time (push gate) |

### High-Risk Variables (DO NOT SET)

| Variable | Risk | Detail |
| --- | --- | --- |
| `CLAUDE_CODE_TEAMMATE_COMMAND` | HIGH | ruvnet gist shows this overrides the spawn command. If Claude Code implements this natively, our value would hijack the native spawn mechanism. Never set this variable. |
| `CLAUDE_CODE_PLAN_MODE_REQUIRED` | MEDIUM | Gist uses this to enforce plan-before-code. If Claude Code adds native plan mode enforcement, our flag might conflict with or duplicate the native behavior, causing double-gating or unexpected plan mode activation. |
| `CLAUDE_CODE_TMUX_*` | LOW | Any `CLAUDE_CODE_TMUX_` prefixed variables. Currently deferred with the tmux panes option. If Claude Code adds native tmux support, namespace collision is possible but unlikely to cause breakage since tmux is our deferred feature. |

### Mitigation Strategy

1. **RALPH_ prefix is safe** -- All `RALPH_*` variables are ours and will never conflict with Claude Code internals.

2. **CLAUDE_CODE_ prefix variables are intentional matches** -- We use `CLAUDE_CODE_TEAM_NAME`, `CLAUDE_CODE_AGENT_ID`, and `CLAUDE_CODE_AGENT_NAME` specifically because we want forward compatibility. If Claude Code natively implements these, our values should align with native expectations.

3. **Version-gated checks** -- When Claude Code ships new env var support, add version detection:
   ```python
   import subprocess
   claude_version = subprocess.check_output(["claude", "--version"]).decode().strip()
   if version_gte(claude_version, "2.2.0"):
       # Use native env vars, skip our overrides
       pass
   else:
       # Set our compatibility vars
       os.environ["CLAUDE_CODE_TEAM_NAME"] = team_name
   ```

4. **Startup conflict detection** -- Log a warning if a `CLAUDE_CODE_*` variable is already set before Ralph touches it:
   ```python
   for var in ["CLAUDE_CODE_TEAM_NAME", "CLAUDE_CODE_AGENT_ID", "CLAUDE_CODE_AGENT_NAME"]:
       if var in os.environ:
           logger.warning(f"{var} already set to '{os.environ[var]}' -- possible native conflict")
   ```

### Monitoring

After each Claude Code update, check:
- `claude --help` for new env var documentation
- Changelog for `CLAUDE_CODE_*` variable additions
- TeammateTool feature flag status (currently gated in v2.1.23)

---

## 5. Deferred Features from ruvnet Gist Analysis

**Source:** [ruvnet gist](https://gist.github.com/ruvnet/18dc8d060194017b989d1f8993919ee4) -- TeammateBridge plugin analysis
**Status:** All items below are deferred. Implement when TeammateTool ships or when use cases demand them.

### Delegation

**What:** An agent delegates a subtask to another agent with authority transfer.

```python
# ruvnet gist pattern
TeammateBridge.delegate(
    from_agent="agent-3",
    to_agent="agent-7",
    task={"type": "fix_lint_errors", "files": ["src/auth.ts"]},
    authority="write",  # delegated permission level
    deadline=300        # seconds
)
```

**Why deferred:** Delegation requires a complex authority model -- which agent can delegate to whom, what permissions transfer, and how to revoke. Current work-stealing queue achieves similar results (any agent claims any pending task) without authority complexity.

**When to implement:** When agents need to hand off partially-completed work to specialists (e.g., a general agent finds a security issue and delegates to the security specialist with context).

### Remote Sync

**What:** Push agent state to a remote location for cross-machine coordination.

```python
# ruvnet gist pattern
TeammateBridge.push_to_remote(
    agent_id="agent-3",
    remote="origin",
    state={"branch": "ralph/agent-3", "tasks_completed": [...]}
)
```

**Why deferred:** `pushToRemote` already exists in ExitPlanMode (git push). Full state sync (not just git) requires serialization of agent context, inbox state, and claimed tasks -- which couples tightly to the SpawnBackend implementation.

**When to implement:** When Ralph agents run across multiple machines or when CI/CD pipelines need to spawn continuation agents from a checkpoint.

### Teleport

**What:** Transfer a running agent's full session context to another agent or machine.

```python
# ruvnet gist pattern
TeammateBridge.teleport(
    from_agent="agent-3",
    to_agent="agent-9",
    include_context=True,    # transfer 200k context window content
    include_tools=True,      # transfer MCP tool state
    include_memory=True      # transfer Serena memories
)
```

**Why deferred:** Requires session serialization -- extracting the full 200k context window, tool state, and in-flight operations from one agent and injecting them into another. Claude Code does not expose a session serialization API. The closest approximation is writing a summary to a shared file, which loses nuance.

**When to implement:** When Claude Code exposes session export/import APIs, or when agents need hot-failover (crashed agent's work continues in a new agent without re-reading all files).

### Transcript Sharing

**What:** Share an agent's conversation transcript with other agents for context.

```python
# ruvnet gist pattern
TeammateBridge.share_transcript(
    from_agent="agent-3",
    to_agents=["agent-0", "agent-7"],
    filter="last_10_turns",  # or "errors_only", "decisions_only"
    format="summary"         # or "full", "structured"
)
```

**Why deferred:** Requires access to the Claude Code session API to read conversation history. Currently, agents can only share context via:
- Writing findings to `.claude/ralph/results/{agent-id}.json`
- Writing to the shared context relay at `.claude/ralph/context-relay.json`
- Serena memory persistence (`mcp__serena__write_memory`)

These are explicit write-based sharing, not transcript replay.

**When to implement:** When Claude Code exposes a transcript/history API, or when the review-then-implement pipeline needs agents to understand the reasoning behind prior agents' decisions (not just their outputs).

### Deferred Features Summary

| Feature | Complexity | Dependency | Workaround Today |
| --- | --- | --- | --- |
| Delegation | High | Authority model | Work-stealing queue (any agent claims any task) |
| Remote Sync | Medium | Session serialization | Git push (code only, not agent state) |
| Teleport | Very High | Session export/import API | Write summary to shared file |
| Transcript Sharing | High | Session/transcript API | Results JSON + context relay + Serena memory |

## Part II: Claude Agent SDK Enhancements

**SDK Version:** `claude-agent-sdk` v0.1.25
**Package:** `pip install claude-agent-sdk` (Python) | `npm install @anthropic-ai/claude-agent-sdk` (TypeScript)
**Docs:** https://platform.claude.com/docs/en/agent-sdk/overview

### Current Integration

Ralph Protocol (`/usr/share/claude/scripts/ralph.py`) now uses the Claude Agent SDK's `query()` function
for spawning agents instead of `asyncio.create_subprocess_exec("claude", "--print")`.

**Key fix:** `setting_sources=None` (SDK default) means NO filesystem settings are loaded, eliminating
the 30-90s MCP server initialization hang that blocked subprocess-based agent spawning.

---

## 6. Programmatic Subagents (`agents` parameter)

**What:** Define specialized agents directly in code with per-agent model, tools, and system prompt.

**SDK API:**
```python
from claude_agent_sdk import query, ClaudeAgentOptions, AgentDefinition

options = ClaudeAgentOptions(
    allowed_tools=["Read", "Grep", "Glob", "Task"],  # Task required for subagents
    agents={
        "code-reviewer": AgentDefinition(
            description="Expert code review specialist.",
            prompt="You are a security-focused code reviewer...",
            tools=["Read", "Grep", "Glob"],       # Restricted tools
            model="sonnet"                          # Per-agent model
        ),
        "test-runner": AgentDefinition(
            description="Runs and analyzes test suites.",
            prompt="You are a test execution specialist...",
            tools=["Bash", "Read", "Grep"],
            model="haiku"                           # Cheaper model for tests
        ),
    }
)
```

**Use case for gswarm-api:**
- Replace the current `_build_agent_prompt()` with typed `AgentDefinition` objects
- Define review agents (security, performance, a11y) as SDK subagents instead of markdown files
- Use `model="haiku"` for read-only review agents (cheaper, faster) and `model="opus"` for complex implementation
- Subagents run in isolated context windows -- exploration results don't pollute the main conversation

**Ralph integration:**
```python
# In ralph.py run_loop(), define agents per role:
review_agents_def = {
    f"reviewer-{specialty}": AgentDefinition(
        description=f"Reviews code for {specialty} issues",
        prompt=load_agent_prompt(specialty),
        tools=["Read", "Grep", "Glob", "Bash"],
        model="sonnet"
    )
    for specialty in ["security", "performance", "a11y", "architecture"]
}
```

---

## 7. Custom MCP Tools (`tool()` decorator)

**What:** Define in-process tools that Claude can invoke, without running external MCP servers.

**SDK API:**
```python
from claude_agent_sdk import tool, create_sdk_mcp_server

@tool("check_gswarm_status", "Check GSwarm node status", {"node_id": str})
async def check_status(args: dict) -> dict:
    node_id = args["node_id"]
    # Check node status via internal API...
    return {"content": [{"type": "text", "text": f"Node {node_id}: healthy"}]}

custom_server = create_sdk_mcp_server(
    name="gswarm-tools", version="1.0.0", tools=[check_status]
)

options = ClaudeAgentOptions(
    mcp_servers={"gswarm-tools": custom_server},
    allowed_tools=["mcp__gswarm-tools__check_gswarm_status"]
)
```

**Use cases for gswarm-api:**
- `check_node_health` -- Check GSwarm node status without Bash commands
- `query_swarm_metrics` -- Pull swarm metrics directly from the API
- `validate_config` -- Validate .env and configuration files programmatically
- `run_migration` -- Execute database migrations with safety checks
- These tools run in-process (no MCP server startup), accessible via `mcp__<server>__<tool>` naming

**Input schema options:**
1. Simple: `{"node_id": str, "timeout": int}`
2. JSON Schema: `{"type": "object", "properties": {...}, "required": [...]}`

---

## 8. Structured Outputs (`output_format`)

**What:** Get JSON schema-validated responses from agents. Guarantees the output matches your schema.

**SDK API:**
```python
from pydantic import BaseModel

class ReviewResult(BaseModel):
    file_path: str
    issues: list[Issue]
    severity: str  # "critical" | "warning" | "info"
    summary: str

options = ClaudeAgentOptions(
    output_format={
        "type": "json_schema",
        "schema": ReviewResult.model_json_schema()
    }
)

async for message in query(prompt="Review auth.ts", options=options):
    if isinstance(message, ResultMessage) and message.structured_output:
        result = ReviewResult.model_validate(message.structured_output)
```

**Use cases for gswarm-api:**
- Review agents return structured `ReviewResult` objects (file, issues, severity) instead of free text
- Agent completion signals as structured data: `{"ralph_complete": true, "files_modified": [...], "tests_passed": bool}`
- Build dashboards from structured agent output (cost tracking, issue counts, etc.)
- Error subtypes: `"success"` or `"error_max_structured_output_retries"` for validation failures

---

## 9. File Checkpointing & Rewinding

**What:** Track file modifications and restore to any previous state. Undo capability for agent edits.

**SDK API:**
```python
options = ClaudeAgentOptions(
    enable_file_checkpointing=True,
    permission_mode="acceptEdits",
)

# Later, rewind to a specific point:
await client.rewind_files(checkpoint_uuid)
```

**Use cases for gswarm-api:**
- Ralph agents can checkpoint before risky changes, rewind on test failure
- Review agents can "try a fix" and rewind if it breaks the build
- Only tracks Write, Edit, NotebookEdit tools (not Bash changes)
- Capture `UserMessage.uuid` as checkpoint ID, pass to `rewind_files()`

---

## 10. Session Management (`resume`, `fork_session`)

**What:** Maintain context across multiple exchanges. Resume or branch conversations.

**SDK API:**
```python
# Capture session ID from first query:
session_id = None
async for message in query(prompt="Analyze the codebase", options=options):
    if hasattr(message, "session_id"):
        session_id = message.session_id

# Resume the same session later:
async for message in query(
    prompt="Now implement the changes we discussed",
    options=ClaudeAgentOptions(resume=session_id)
):
    ...

# Fork to explore alternative approach:
async for message in query(
    prompt="Try a different architecture",
    options=ClaudeAgentOptions(resume=session_id, fork_session=True)
):
    ...
```

**Use cases for gswarm-api:**
- Multi-phase Ralph agents: analysis phase -> implementation phase -> test phase (same context)
- Fork sessions to try different implementation approaches in parallel
- Resume failed agents from their last checkpoint instead of starting over
- Subagent transcripts persist at `~/.claude/projects/{project}/{sessionId}/subagents/`

| Behavior | `fork_session=False` | `fork_session=True` |
|----------|---------------------|---------------------|
| Session ID | Same as original | New ID generated |
| History | Appends to original | Creates branch |
| Original | Modified | Preserved |

---

## 11. Dynamic Permissions (`can_use_tool` callback)

**What:** Runtime permission decisions based on tool name, input, and context.

**SDK API:**
```python
async def permission_handler(
    tool_name: str, input_data: dict, context: ToolPermissionContext
) -> PermissionResultAllow | PermissionResultDeny:
    # Block writes to protected paths
    if tool_name in ("Write", "Edit"):
        path = input_data.get("file_path", "")
        if path.startswith("/etc/") or ".env" in path:
            return PermissionResultDeny(
                message=f"Protected path: {path}",
                interrupt=True  # Stop agent entirely
            )
    # Allow with modified input
    return PermissionResultAllow(updated_input=input_data)

options = ClaudeAgentOptions(can_use_tool=permission_handler)
```

**Use cases for gswarm-api:**
- Block agents from modifying `.env`, `credentials.json`, or `*.key` files
- Allow Bash commands but filter out `rm -rf`, `git push --force`, etc.
- Log all tool uses for audit trail
- Return `PermissionResultAllow(updated_input=modified_input)` to sanitize inputs
- `interrupt=True` on deny stops the agent entirely vs just skipping the tool call

**Permission modes:**

| Mode | Behavior | Use case |
|------|----------|----------|
| `default` | Requires `can_use_tool` callback | Custom approval flows |
| `acceptEdits` | Auto-approves file edits | Trusted development |
| `bypassPermissions` | All tools run without prompts | CI/CD, automation |
| `plan` | No tool execution (read-only) | Planning phase |
## 12. Hooks (Python SDK)

**What:** Intercept agent execution at key points for validation, logging, security.

**SDK API (Python-supported hooks):**
```python
from claude_agent_sdk import ClaudeAgentOptions, HookMatcher

options = ClaudeAgentOptions(
    hooks={
        "PreToolUse": [
            HookMatcher(
                matcher="Write|Edit",     # Regex on tool name
                hooks=[validate_write],   # Callback functions
                timeout=120               # Seconds
            )
        ],
        "PostToolUse": [
            HookMatcher(hooks=[log_tool_use])  # No matcher = all tools
        ],
        "Stop": [
            HookMatcher(hooks=[on_agent_stop])
        ],
        "SubagentStop": [
            HookMatcher(hooks=[on_subagent_done])
        ],
    }
)
```

**Hook callback signature:**
```python
async def validate_write(
    input_data: dict,         # Event details (tool_name, tool_input, etc.)
    tool_use_id: str | None,  # Correlate Pre/PostToolUse events
    context: HookContext       # Contains signal (future)
) -> dict:
    return {
        "continue_": True,                    # Python uses underscore
        "hookSpecificOutput": {
            "hookEventName": "PreToolUse",
            "permissionDecision": "allow",    # or "deny" or "ask"
        }
    }
```

**Python-supported hook events:**

| Hook | Trigger | Use case |
|------|---------|----------|
| `PreToolUse` | Before tool execution | Block/modify tool calls |
| `PostToolUse` | After tool execution | Audit logging |
| `UserPromptSubmit` | User prompt submission | Input validation |
| `Stop` | Agent stops | Cleanup, push gate |
| `SubagentStop` | Subagent completes | Collect results |
| `PreCompact` | Before context compaction | Checkpoint state |

**Note:** Python SDK does NOT support: SessionStart, SessionEnd, Notification, PostToolUseFailure, SubagentStart, PermissionRequest. These are TypeScript-only.

**Use cases for gswarm-api:**
- Ralph push gate: `Stop` hook verifies all commits are pushed before allowing completion
- Audit trail: `PostToolUse` logs every file edit with timestamp
- Safety: `PreToolUse` blocks dangerous Bash commands
- Subagent tracking: `SubagentStop` collects review results from each agent

---

## 13. ClaudeSDKClient (Multi-Turn Conversations)

**What:** Persistent session for interactive multi-turn conversations with interrupt support.

**SDK API:**
```python
from claude_agent_sdk import ClaudeSDKClient, ClaudeAgentOptions

async with ClaudeSDKClient(options=ClaudeAgentOptions(
    allowed_tools=["Read", "Edit", "Bash"],
    permission_mode="acceptEdits",
)) as client:
    # First query
    await client.query("Analyze the authentication module")
    async for message in client.receive_response():
        print(message)

    # Follow-up in same context (remembers previous analysis)
    await client.query("Now implement the fixes we discussed")
    async for message in client.receive_response():
        print(message)

    # Interrupt if taking too long
    await client.interrupt()
```

| Feature | `query()` | `ClaudeSDKClient` |
|---------|-----------|-------------------|
| Session | New each time | Reuses same session |
| Conversation | Single exchange | Multi-turn |
| Hooks | Not supported | Supported |
| Custom Tools | Not supported | Supported |
| Interrupts | Not supported | Supported |

**Use cases for gswarm-api:**
- Multi-phase Ralph agents: analyze -> implement -> test in same context
- Interactive debugging sessions where agent remembers state
- Custom MCP tools only work with `ClaudeSDKClient` (streaming mode required)
- Interrupt long-running agents that are stuck

---

## 14. Budget Control (`max_budget_usd`)

**What:** Set per-session cost limits to prevent runaway spending.

**SDK API:**
```python
options = ClaudeAgentOptions(
    max_budget_usd=5.00,  # Stop after $5
    max_turns=100,         # Also limit turn count
)
```

**Use cases for gswarm-api:**
- Set budget per Ralph agent: `max_budget_usd=2.00` (10 agents * $2 = $20 max session)
- Review agents: `max_budget_usd=0.50` (cheaper, read-only)
- Implementation agents: `max_budget_usd=5.00` (more complex work)
- Track actual spend via `ResultMessage.total_cost_usd` and `ResultMessage.usage`

---

## 15. Model Selection Per Agent

**What:** Different models for different agent types.

**SDK API:**
```python
# Via ClaudeAgentOptions
options = ClaudeAgentOptions(
    model="claude-sonnet-4-5",
    fallback_model="claude-haiku-3-5",  # If primary fails
)

# Via AgentDefinition (subagents)
agents = {
    "analyzer": AgentDefinition(
        description="...", prompt="...",
        model="haiku"      # Fast, cheap for analysis
    ),
    "implementer": AgentDefinition(
        description="...", prompt="...",
        model="opus"       # Best for complex implementation
    ),
}
```

**Model aliases:** `"sonnet"`, `"opus"`, `"haiku"`, `"inherit"` (parent's model)

**Use cases for gswarm-api:**
- Review agents: `model="haiku"` (fast, cheap, read-only analysis)
- Implementation agents: `model="sonnet"` (balanced capability/cost)
- Architecture decisions: `model="opus"` (highest capability)
- Fallback model prevents failures from model-specific outages

---

## 16. Settings Sources Control

**What:** Selective loading of filesystem settings (hooks, permissions, MCP servers).

**SDK API:**
```python
# No settings loaded (fastest startup -- SDK default)
options = ClaudeAgentOptions()  # setting_sources=None

# Load project settings only (CLAUDE.md, .claude/settings.json)
options = ClaudeAgentOptions(setting_sources=["project"])

# Load all settings
options = ClaudeAgentOptions(setting_sources=["user", "project", "local"])
```

| Value | Location | Loads |
|-------|----------|-------|
| `"user"` | `~/.claude/settings.json` | User hooks, permissions |
| `"project"` | `.claude/settings.json` | Project hooks, MCP servers |
| `"local"` | `.claude/settings.local.json` | Local overrides |

**Current usage in Ralph:**
- `setting_sources=None` (default) -- eliminates MCP initialization hang
- Future: `setting_sources=["project"]` to load CLAUDE.md instructions into agents

**Note:** Programmatic options always override filesystem settings. Precedence: Local > Project > User.

---

## 17. Plugin System

**What:** Load custom extensions from local directories.

**SDK API:**
```python
options = ClaudeAgentOptions(
    plugins=[
        {"type": "local", "path": "./my-plugin"},
    ]
)
```

**Plugin structure:**
```
my-plugin/
  .claude-plugin/plugin.json   # Required manifest
  commands/                     # Slash commands
  agents/                       # Subagents
  skills/                       # Skills
  hooks/                        # Event handlers
  .mcp.json                     # MCP servers
```

**Use cases for gswarm-api:**
- Package GSwarm-specific commands, agents, and hooks as a plugin
- Distribute to team members via `plugins` option
- Commands namespaced as `plugin-name:command-name`
## 18. Sandbox Configuration

**What:** Security boundaries for agent execution.

**SDK API:**
```python
options = ClaudeAgentOptions(
    sandbox={
        "enabled": True,
        "autoAllowBashIfSandboxed": True,
        "excludedCommands": ["docker", "sudo"],
        "allowUnsandboxedCommands": False,
        "network": {
            "allowLocalBinding": True,
            "allowUnixSockets": [],
            "allowAllUnixSockets": False,
        },
        "ignoreViolations": {
            "file": [],
            "network": []
        },
    }
)
```

**Use cases for gswarm-api:**
- Sandbox review agents: prevent network access, limit to read-only
- Allow implementation agents: `autoAllowBashIfSandboxed=True` for build/test
- Exclude dangerous commands: `["docker", "sudo", "rm -rf"]`
- CI/CD: `"allowUnsandboxedCommands": False` for maximum security

---

## 19. Streaming Input (Multi-Modal)

**What:** Send images, queue messages, and interact with running agents.

**SDK API:**
```python
async def message_stream():
    yield {"type": "user", "message": {"role": "user", "content": "Analyze this codebase"}}
    await asyncio.sleep(2)
    yield {"type": "user", "message": {"role": "user", "content": [
        {"type": "text", "text": "Review this screenshot"},
        {"type": "image", "source": {
            "type": "base64", "media_type": "image/png", "data": img_data
        }}
    ]}}

async for msg in query(prompt=message_stream(), options=options):
    ...
```

**Use cases for gswarm-api:**
- Send screenshots for visual verification (`/launch` integration)
- Queue additional instructions mid-task
- Multi-modal analysis (screenshot + code context)

---

## 20. Extended Context (Beta)

**What:** 1M token context window for large codebases.

**SDK API:**
```python
options = ClaudeAgentOptions(
    betas=["context-1m-2025-08-07"],
    max_thinking_tokens=32000,  # Extended thinking
)
```

**Use cases for gswarm-api:**
- Review agents analyzing entire modules without context window limits
- Architecture review spanning the full codebase
- Only available on Sonnet 4+ and Opus 4+ models

---

## 21. Slash Commands (Custom)

**What:** Custom commands defined as markdown files.

**SDK API:**
```python
# Load project commands via settings
options = ClaudeAgentOptions(
    setting_sources=["project"],  # Loads .claude/commands/*.md
    allowed_tools=["Skill", ...],
)
```

**Command file format (`.claude/commands/review-auth.md`):**
```markdown
---
allowed-tools: Read, Grep, Glob
description: Review authentication module
model: claude-sonnet-4-5-20250929
---
Review the authentication module for security issues.
Focus on: $ARGUMENTS
```

**Features:**
- Arguments: `$1`, `$2`, `$ARGUMENTS` (positional and full)
- Bash execution: `` !`git status` `` (inline bash in prompts)
- File references: `@package.json` (inject file content)

---

## 22. Hosting & Deployment Patterns

**Deployment models:**

| Pattern | Description | Use case |
|---------|-------------|----------|
| Ephemeral | New container per task, destroyed on complete | CI/CD, one-off tasks |
| Long-Running | Persistent container, maintains state | Proactive monitoring |
| Hybrid | Ephemeral + hydrated history/state | Cost-effective multi-session |
| Single Container | Multiple SDK processes in one container | Agent collaboration |

**System requirements:**
- Python 3.10+ or Node.js 18+
- Claude Code CLI installed
- 1 GiB RAM, 5 GiB disk, 1 CPU recommended
- Network: Outbound HTTPS to `api.anthropic.com`

**Sandbox providers:** Modal, Cloudflare, Daytona, E2B, Fly Machines, Vercel Sandbox

---

## 23. Authentication Methods

| Method | Env Var | Use case |
|--------|---------|----------|
| Anthropic API Key | `ANTHROPIC_API_KEY` | Default, direct API |
| Amazon Bedrock | `CLAUDE_CODE_USE_BEDROCK=1` | AWS infrastructure |
| Google Vertex AI | `CLAUDE_CODE_USE_VERTEX=1` | Google Cloud |
| Microsoft Foundry | `CLAUDE_CODE_USE_FOUNDRY=1` | Azure |
| Claude CLI auth | (auto-detected) | Local development |

**Current gswarm-api:** Uses Claude CLI auth (auto-detected from `claude auth login`).
## Implementation Priority

| # | Feature | Impact | Effort | Status |
|---|---------|--------|--------|--------|
| 6 | SDK `query()` for agent spawning | Critical (fixes hang) | Done | **Implemented** |
| 7 | Programmatic subagents | High (typed review agents) | Medium | Planned |
| 8 | Structured outputs | High (parseable results) | Low | Planned |
| 9 | Budget control | Medium (cost management) | Low | Planned |
| 10 | Model selection per agent | Medium (cost optimization) | Low | Planned |
| 11 | File checkpointing | Medium (undo capability) | Low | Planned |
| 12 | Dynamic permissions | Medium (security) | Medium | Planned |
| 13 | Session resume/fork | Medium (fault tolerance) | Medium | Planned |
| 14 | Custom MCP tools | Low (convenience) | Medium | Future |
| 15 | Plugin system | Low (distribution) | High | Future |
| 16 | Sandbox config | Low (security boundary) | Medium | Future |
| 17 | Streaming input | Low (multi-modal) | Medium | Future |

---

## Migration Notes

**Package rename (v0.1.0):**
- Python: `claude-code-sdk` -> `claude-agent-sdk`
- Import: `claude_code_sdk` -> `claude_agent_sdk`
- Type: `ClaudeCodeOptions` -> `ClaudeAgentOptions`

**Breaking changes in v0.1.0:**
1. System prompt no longer default (must use `{"type": "preset", "preset": "claude_code"}`)
2. Settings sources no longer loaded by default (must set `setting_sources`)
3. `ClaudeCodeOptions` renamed to `ClaudeAgentOptions`

---

## References

- [Agent SDK Overview](https://platform.claude.com/docs/en/agent-sdk/overview)
- [Python SDK Reference](https://platform.claude.com/docs/en/agent-sdk/python)
- [TypeScript SDK Reference](https://platform.claude.com/docs/en/agent-sdk/typescript)
- [Subagents Documentation](https://platform.claude.com/docs/en/agent-sdk/sub-agents)
- [Quickstart Guide](https://platform.claude.com/docs/en/agent-sdk/quickstart)
- [SDK Demo Agents](https://github.com/anthropics/claude-agent-sdk-demos)
